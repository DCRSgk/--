# day25 笔记

[TOC]

### Ep01 写在前面 记得去重听压缩和scp

- pid



### Ep02 批量替换文件

- shell上批量替换

  > - `sed "s/[修改目标]/[修改内容]/g"+文件名 `
  >   - 只显示修改结果，不修改实际内容
  > - 批量替换：
  >   - `sed "s/[修改目标]/[修改内容]/g " *.c`
  >   - `find . -name "*.c" |xargs sed "s/[修改目标]/[修改内容]/g "`利用fing命令和管道
  > - 保存修改：`sed "s/[修改目标]/[修改内容]/g"+文件名 -i `

- 文件的对比

  > - `vimdiff [文件名1] [文件名2]`
  > - 尽可能的多匹配公共部分

- vim配置文件

  > - vimrc

### Ep03：编译工具：gcc工具链（SDK）

- 编译工具：gcc工具链（SDK）

  > - 程序的编译过程
  >
  >   - 预处理：将所有的#include头文件以及宏定义替换成其真正的内容
  >     - 处理之后仍是代码文件，后缀为.i
  >   - 编译：将经过预处理之后的程序转换成特定汇编代码的过程
  >     - 处理后为汇编代码，后缀为.s文件
  >   - 汇编：汇编过程将上一步的汇编代码转换成机器码
  >     - 处理之后为二进制文件，后缀为.o
  >   - mn链接：链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件。
  >     - 确定 .o文件的地址
  >
  > - 函数首先分配栈帧
  >
  > - 变量都转换成地址
  >
  > - 函数调用是使用其他函数的代码
  >
  > - 循环是用跳转实现的
  >
  > - 看汇编需要注意：
  >
  >   - 找自己看得懂的查
  >   - 分块看 找变量的地址
  >
  > - gcc参数
  >
  >   - |  参数   |                 含义                 |
  >     | :-----: | :----------------------------------: |
  >     |   -E    |     预处理（生成后缀为.i的文件）     |
  >     |   -S    | 编译成汇编文件（生成后缀为.s的文件） |
  >     | -o 目标 |           生成文件到目标内           |
  >     |   $as   | 汇编文件转换成二进制的目标文件（.o） |
  >     |   $nm   |          查看二进制的符号表          |
  >     |    %    |                 链接                 |
  >     | gcc -c  |            快速生成.o文件            |
  >
  > - 其他编译选项
  >
  >   - |  编译选项   |                  功能                  |
  >     | :---------: | :------------------------------------: |
  >     | -I [目录名] | 指定头文件的目录（编译时）方便调整文件 |
  >     |   -D 宏名   |    相当于再代码头部添加一个#define     |
  >     |    -Wall    |            **打开编译警告**            |
  >     |   -O[123]   |              控制优化级别              |
  >     

### Ep04 库

- 静态库

  > - 链接的时候将库文件打包到程序里面
  > - 优点
  >   - 容易部署
  > - 劣势
  >   - 难以升级
  >   - 体积大
  > - 生成静待库
  >   - `gcc -c [文件名]` →此时生成一个[文件名].0的文件
  >   - `ar crsv lib[文件名].a [文件名].0`：打包，文件名为库的名字。生成一个.a文件
  >   - 将静态库复制到库路径中：`cp lib[文件名].a /usr/lib`
  >   - `gcc -o mian mian.c -l[库名称] `：链接，在编译的时候加上名称

- 动态库
  
  > - 链接的时候将得到库文件的位置，在运行的时候再加载到程序里面
  >
  > - 优点
  >   - 易升级
  >   - 体积小
  > - 劣势
  >   - 不容易部署
  >   - 体积大
  > - 定义并链接动态库
  >   -   `gcc -c [库名].c -fpic`
  >   - ``gcc -shared -o lib[库名].so add.o`
  > - 查看依赖的动态库：`ldd`
  > -  //动态库版本更新：重听

### Ep05 GDB调试器

- 使用要求

  > - 程序编译时需要加上-g操作 
  >
  > - 调试快捷键：
  >
  >   - | 操作          | 功能                                |
  >     | ------------- | :---------------------------------- |
  >     | **l/list**    | **显示代码**                        |
  >     | **r/run**     | **运行**                            |
  >     | **b/break**   | **打断点（加数字显示在x行打断点）** |
  >     | **info b**    | **显示所有断点**                    |
  >     | s/step        | 单步调试并且进入函数                |
  >     | finish        | 退出当前函数                        |
  >     | n/next        | 单步调试                            |
  >     | c/continue    | 运行到下一个断点                    |
  >     | delete        | 删除所有断点                        |
  >     | bt/backtrance | 调用堆栈                            |
  >     | p             | 监视：                              |
  >
  >   - set args ：设置命令行参数
  >   
  >   - show args ：查看命令行参数
  >   
  >   - bt查看堆栈
  >   
  > - 段错误和core文件
  >   
  > - 段错误：编译没问题但是在执行的过程中会出现比如访问越界，
  >   - ![image-20200410170149499](day25 笔记.assets/image-20200410170149499.png)
  >   
  >   

