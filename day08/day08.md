# day08

### Ep01 写在前面

- 代码问题：拿出纸和笔，分析问题，提出解决方案并检查和调整。
- 锻炼自己的调试能力

- 找到问题解决，提问。
- 复习指针和数组
- 二级指针和函数指针
- 讲解习题（103个数找三个有差异的数）

### Ep02 数组指针和二维数组

- 数组指针和二维数组

  > - 定义
  >
  > - ```c++
  >   #include<iostream>
  >   #include<string>
  >   using namespace std;
  >   void print(int p[][4],int row);
  >   int main()
  >   {
  >   	int a[3][4]={1,3,5,7,2,4,6,8,9,11,13,15};
  >       int (*p)[4];
  >       int b[4]={1,2,3,4};
  >       //&b+1=>偏移16个字节的下一个数组 基类型是大小为16个字节的数组
  >       //*(*(a+1)+1) 得到4的办法 偏移两次
  >       //第一次偏移成一个一维数组 第二次再次偏移成一个一维数组中的一个元素
  >     	p=a;  
  >       print(a,3);
  >       /*
  >       p=(int (*)[4]malloc(16*100));
  >       p[99][3]=1000; //动态二维数组
  >       */ 
  >   }
  >   void print(int p[][4],int row)
  >   {
  >       printf("sizeof(p)=%d\n",sizeof(p));
  >       //sizeof只看类型，所以这里p的类型是指针 占4个字节
  >       for(int i=0;i<row;i++)
  >       {
  >          for(int j=0;j<sizeof(*p)/sizeof(int);j++)
  >           {
  >              printf("%3d",*(p[i]+j); //比较容易看懂
  >                  //等价于  *(*p+i)+j     
  >           }
  >           cout<<endl;
  >       }
  >   }
  >   ```
  >
  > - 

### Ep03 指针和数组复习

- 数组

  > - 定义：数据类型+数组名+[数组大小]
  >
  >   - 初始化 = {0}  //自动推导大小：忽略数组大小，根据初始化列表自动推断
  >
  > - 调用数组：数组名+[数组下标]
  >
  >   - 数组下标范围0~数组大小-1
  >   - []的原理：数组指针的偏移 `p[i]`等价于 `*(p+i)`
  >
  > - 数组和指针
  >
  >   - 数组名的数据类型？数值？
  >     - 数组名 = 首个元素的地址 = 数组的地址 = 首地址的指针
  >     - 类型以**元素类型为基类型的指针**
  >     - 不能修改指向但是可以修改指向位置的值：const pointer //指针常量
  >   - e
  >
  > - 二维数组
  >
  >   - 定义：数据类型+数组名+[行] [列]
  >   - 内存分布：同一行连续存储，行与行之间也连续存储，地址连续。
  >     - 按行存储
  >     - 行与行之间也连续存储
  >   - 本质：数组的数组 可以看作是大小为**[行]**的**[列]**个一维数组
  >   - 二维数组数组名的含义：int arr[M] [N]
  >     - arr：基类型是int[N]的指针。
  >     - arr+1 地址值增加了 1 * sizeof（int）*N
  >     - 在函数内：``*arr+1  `    1 * sizeof（int）*N
  >
  > - 字符数组
  >
  >   - 字符串的特点：以\\0结尾的字符数组
  >
  >     - 不会检查数组的大小
  >
  >   - 字符串的使用问题：
  >
  >     - char str[20] ="hello world"
  >
  >     - 使用函数读取的时候：请务必用memset将空间中所有的位置都设置为0；
  >
  >     - 使用memset清空 `char str[30]`
  >
  >       - ```c++
  >         char str[30];
  >         memset(str,0,sizeof(str));
  >         ```
  >
  >       - 一些函数
  >
  >         - strlen.. 表格见笔记
  >
  >       - 大小：什么时候可以用sizeof

- 指针

  > - 概念：存放了已分配空间的地址的一个变量
  > - 定义：基类型 *指针名
  >   - 指针的数据类型由基类型决定
  >   - 解引用、间接访问的空间大小和解释方式
  >     - 解引用：
  >     - 间接访问：用指针访问变量类型
  > - 指针的偏移：
  >   - 根据指针的基类型的大小进行地址的增加/减少
  >   - 注意指针的偏移和数组之间的联系。
  > - 动态数组
  >   - 分配在堆上
  >   - (基类型*)malloc(数组大小 *sizeof(基类型))
  >   - 申请：p=(基类型*)malloc(数组大小 *sizeof(基类型))
  >     - 不要越界 ：0~（数组大小-1）
  >   - 释放 free（p） ，注意此时P的指向不能偏移
  >   - 注意此时还需将p=NULL 避免野指针。
  >   - 、
  > - 指针的传递
  >   - 在被调函数里修改主函数的值？
  >     - 1. 主调函数将变量的地址传入被调函数（实参= 地址）
  >     - 2. 被调函数用接引用（间接访问）的方式修改变量的值
  >          - 间接访问的方式：* []  ->

### Ep04 二级指针与函数指针

- 二级指针与函数指针

  > - ![image-20200324145304521](C:\Users\GK\AppData\Roaming\Typora\typora-user-images\image-20200324145304521.png)
  >
  >   - | 表示形式                   | 含义                                        | 地址值     |
  >     | -------------------------- | ------------------------------------------- | ---------- |
  >     | `a`                        | 二维数组名，指向一维数组a[0]，即0行的首地址 | 0x2000     |
  >     | `a[0]`，`*(a+0)`，`*a`     | 0行0列的元素地址                            | 0x2000     |
  >     | `a+1`，`&a[1]`             | 1行首地址                                   | 0x2010     |
  >     |                            | 1行0列元素``a [1] [0]``的地址               | 0x2010     |
  >     |                            |                                             | 0x2018     |
  >     | `*(a[1]+2)`，`*(a(a+2)+2)` | 1行2列元素`a[1][2]`的值                     | 元素值为13 |
  >
  >   - 每次偏移+4
  >
  > - 数组指针
  >
  >   - 二维数组可以看成元素为一维数组的数组
  >   - 一维数组的数组名在进行偏移和解引用之后，可以看作是以元素类型为基类型的指针
  >
  > - 如何排序二维数组
  >
  >   - 数组指针
  >     - strcpy/ memcpy
  >   - 二级指针
  >     - 交换指针排序
  >   - 函数指针
  >
  > - 心中要由一幅指针指向的内存图
  >
  > - 常见问题
  >
  >   - ```c++
  >     int a[4][4];
  >     int *p=a;
  >     int *q=a[0];
  >     //p&&q的数据类型一样能够说明a个a[0]一样吗？
  >     //不一样 p++和q++就可以看出区别
  >     int (*p)[4]=a;
  >     
  >     ```
  >
  > - 二级指针
  >
  >   - 定义：基类型为指针类型的指针
  >   - 改变指针的指针
  >   - 二级指针的传递  //晚上重听
  >   - ![image-20200324151119523](C:\Users\GK\AppData\Roaming\Typora\typora-user-images\image-20200324151119523.png)
  >   - 改变i的值需要传入i的地址



- 函数指针（概念复杂，使用简单）

  > - 定义：存储函数入口地址的指针
  >
  > - 使用场景：间接引用函数
  >
  > - 功能：传递
  >
  > - ```c++
  >   //定义函数指针
  >   //void (*p)(形参);//这是一个指针，返回值为void。
  >   void b(){
  >       printf("i am ironman \n");
  >   }//返回值是void 无形参
  >   void a(void(*p)(int))
  >   {
  >       p(3);
  >   }
  >   int main(){		//定义的时候要形参
  >       void(*p);	//调用的时候要传递实参
  >       p=b;
  >       //p（2);//使用函数指针间接访问b函数
  >       a(p);
  >   }//函数名单独使用，就是函数指针
  >   ```
  >
  > - 
  >
  > - 函数指针的实际使用场景
  >
  >   - 集中某个地址
  >   - 元素为指针的数组
  >   - 对某商品进行排序的时候 交换指针比交换结构体简单
  >   - 



- 使用指针数组排序字符串

  > - ```c++
  >   char b[5][10]={"lele","lili","lilei","hanmeimei","zhousi"};
  >   char* p[5];
  >   for (int i=0;i<5;i++)
  >   {
  >       p[i]=b[i];//对于二维数组的列下标来说 一个列下标表示一行，每行的开头元素就是基类型为一整行的指针。
  >   }
  >   //排序p用冒泡排序
  >   char **p2 = p;
  >   for(int i=4;i>=1;--i)
  >   {
  >       for(int j=0;j<i;++j)
  >       {
  >           if(strcmp(p2[j],p2[j+1]))
  >           {
  >               char *tmp=p2[j];
  >               p2[j]=p2[j+1];
  >               p2[j+1]=tmp; //交换
  >           }
  >       }
  >       print(p2);
  >       puts("------------------");
  >       for(int i=0;i<=4;i++)
  >       {
  >           puts(b[i]);
  >       }
  >   } 
  >   ```

- 二维数组VS二级指针

  > - 在默认的情况下二者没有联系
  >
  > - ```c++
  >   int a[4][3];
  >   /*
  >   a => 数组名 /指向数组的指针
  >   a[0] => int[3]/int*
  >   a[0][1] => int
  >   //二维数组的解引用流程不涉及二级指针
  >   */
  >   
  >   ```
  >
  > - 

