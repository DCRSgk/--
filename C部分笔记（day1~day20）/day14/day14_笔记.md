---
typora-root-url: ..\assess
---

# day14

### Ep01

- 调试相关：
  - 调试的时候先查看调用堆栈
  - 如果访问越界的位置可读可写则不会异常
  - 如果访问越界的位置不可读不可写则直接报错
  - 对于qsort ：检查compare类型转换，检查qsort入参

### Ep02

- hash查找

  > -  

### Ep03

- 

  - 空间复杂度为0(1)

  - memmove的实现

  - ```c++
    memmove(to,from){
        有重叠，还是复制COPY;
        判断to和from的位置
        
    }
    ```

### Ep04 红黑树

- 红黑树的特点

  > - 节点是红色||黑色
  > - 根是黑色
  > - 所有叶子节点都是黑色
  > - 每个红色节点都必须有两个黑色的叶子节点
  > - 从任意节点到其每个叶子节点的所有简单路径都包含着相同路径的黑色节点
  > - （从根节点到任何一个叶子节点的黑色节点数目是相等的）
  > - 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。

- 

### Ep05 复习内容

- 查找

  > + 二分查找
  >
  >   + 必须有序
  >   + 时间复杂度为`O(logn)`
  >
  > + 哈希查找
  >
  >   + 时间复杂度为`O(1)`
  >
  >   + 哈希的流程
  >
  >     + 确定哈希公式
  >
  >     - 创建一个空数组
  >     - 通过将元素传入哈希公式得到返回值，凭借返回值
  >
  >     + ```c++
  >       "当战"---> int hash(char*)
  >       ```
  >
  >     + 插入哈希数组，返回值作为数组下标ret∈（0~maxkey-1）
  >
  >     + 将带插入的数据传入哈希函数，得到返回值
  >
  >     + 检查数组内容

- 高级数据结构

  > - 二叉排序树
  >   - 
  >
  >  - 二叉排序树树的旋转
  > 	 - 左旋：根`->`左孩子
  >      - ![image-20200331162619681](/../day14/day14_笔记.assets/image-20200331162619681-1585643232005.png)
  >     
  >  - 右旋相反：根`->`右孩子
  >
  > - 红黑树（节点有颜色的二叉排序树）
  >
  >   - 对于任意一棵子树
  >
  >   - 左子树的最大值小于根节点小于右子树的最小值。
  >
  >   - 用人话来说就是左边最小中间次之右边最大
  >
  >   - ```c++
  >     1 2 3 
  >         1						1
  >          \						  \
  >            2						3	
  >              \					  /	
  >                3				2
  >     ```
  >
  >   - 给出相同的数据，有不同的排列结果
  >
  >   - 中序遍历结果相同
  >
  > - 红黑树的性质
  >
  >   - 节点必须是红||黑（节点必须有颜色）
  >   - 根节点必须是黑色
  >   - 每个红色节点必须有两个黑色的孩子
  >   - 两个红色节点不能连续
  >   - 根到叶子经历的黑色结点数要相同
  >
  > - 红黑树的插入问题
  >
  >   - 每次加入的节点都是红的
  >   - 按照二叉排序树的方式定位插入位置
  >   - 不需要旋转
  >     1. 父红叔红`->`父叔染黑爷染红（相当于在爷的位置插入新节点）
  >     2. 如果根是红`->`直接染黑
  >     3. 如果父是黑`->`不变
  >   -  根`->`直接染黑
  >   - 父为黑`->`直接不变
  >   - 父为红
  >     - 叔为红则父叔染黑爷染红（向上递归）
  >     - 叔为黑或不存在
  >       - 腰`->`裙子
  >       - 裙子`->`把多的向少的旋转&&爷爷染黑父和叔染红
  >
  > - 如何删除二叉排序树
  >
  >     - 如果是叶子节点，直接删除
  >     - 如果有孩子节点
  >         - (需要找到最接近节点值的叶子节点替换之后删除叶子）
  >         - 找到孩子的左子树左右边或者右子树最左边（最接近的值）
  >         - 用叶子节点覆盖源节点
  >         - 删除叶子
  >     - 仅有左或者右子树的结点：删除结点后，将它的左子树或者右子树整个移动到删除结点的位置。
  >

