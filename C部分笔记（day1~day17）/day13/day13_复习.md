# 22

### Ep01

- 排序

  > - 冒泡
  >
  >   - 依次找到第N大，第N-1大......
  >   - 从0开始到N-1，依次和后面的元素比较&交换
  >
  > - 选择
  >
  >   - 依次找到第N大，第N-1大......
  >   - 利用查找最大值的方法
  >
  > - 插入
  >
  >   - 有一个有序的数组，大小为1
  >   - 将剩余元素依次插入到数组中
  >
  > - 希尔排序（优化插入）
  >
  > - 快速
  >
  >   - 给定一个分割值，找到分割值为第几大（partition）
  >
  >   - 把原来的数组划分成两部分，递归调用
  >
  >   - 直到数组元素小于两个
  >
  >   - 最坏时间复杂度堪比冒泡
  >
  >   - 对于非递归版本的快排，仅使用qsort
  >
  >     - 对于浮点数，需要
  >
  >     - ```c++
  >       if (left>right)
  >       {
  >           return 1;
  >       }
  >       else if(left<right)
  >       {
  >           return -1;
  >       }else{
  >           return 0;
  >       }
  >       ```
  >
  >     - ~~不然到时候排序出现了误差是要负责任的~~
  >
  > - 堆
  >
  >   - 形状性质[^R1]
  >
  >     - 完全二叉树[^R2]
  >     - 数组存储
  >
  >   - 数量性质
  >
  >     - 对于每个子树都必须有以下二者之一的数量关系：
  >       - 根大于左&&根大于右（最大堆||大根堆）
  >       - 根小于左&&根小于右（最小堆||小根堆）
  >
  >   - 左右孩子比较，大的去和父亲节点比较。
  >
  >   - 父节点比较完，大的作为新的父节点和原来的交换位置
  >
  >   - 只要发生交换，则会影响下面的节点，重新比较
  >
  >   - 单次调整
  >
  >     - 左右孩子对抗
  >     - 父子节点对抗， 发生交换
  >     - 向下重复对抗，直到没有发生交换
  >
  >   - 堆排序
  >
  >     - 依次找到第N大，N-1大.....
  >
  >     - 根节点永远是堆中最大的数
  >
  >     - 步骤：
  >
  >       > 1. 建堆
  >       > 2. 交换堆尾和堆顶
  >       > 3. 缩小堆的规模，重建堆，直到堆里只有两个元素
  >
  > - 归并排序[^R3]:
  >
  >   - 归并排序：总的元素个数不变
  >   - 快速排序：总的元素个数-1
  >   - 平均分割数组，并合并有序值
  >   - 优点：可以进行外排序（多级排序）
  >   - 缺点：占据额外的空间
  >   - 递归过程
  >     - 对左右的数组进行递归调用
  >     - 合并有序
  >     - 当数组元素小于2时为递归出口
  >
  > - 计数排序
  >
  >   - 最快的排序，但是占空间
  >   - 对于数组变化范围很大的情况，会占据较大的空间
  >   - 步骤
  >     - 建立额外数组。额外数组的大小由原数组数据的范围决定，额外数组初始化为0
  >     - 遍历原数组，根据元素的数值，找到下标，在额外数组的下标位置进行一次自增
  >     - 遍历额外数组，根据额外数组元索的数值，确定该下标在原数组的重复次数，重新写回原数组
  >   - 考虑重复问题请务必考虑计数排序
  >     - 额外数组退化为位图，能剩极大的空间
  >   - 

- 快速排序的时间复杂度

  > - 平均为`n*logn`
  > - 最坏：`n^2`恰好有序时，退化为选择排序
  > - 

[^R1]:在我们说堆排之前先要说说堆
[^R2]:一棵完全二叉树中，假如根节点是`i`那么左孩子为`2i`右孩子为`2*i+1`

[^R3]:在我们说归并之前先说说快排和归并的区别